# -*- coding: utf-8 -*-
"""super_market.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rk_Eri6_acO4i_58xEbxHUl7BNF7PVTb

# ğŸ›’ Super Market - AnÃ¡lise de Dados com Python, Google Colab e SQLite

Este projeto apresenta uma anÃ¡lise de dados de supermercado utilizando **Python em Google Colab**, com **persistÃªncia dos dados via SQLite** salvo diretamente no **Google Drive**.

Todos os notebooks e arquivos sÃ£o versionados via **GitHub**, permitindo organizaÃ§Ã£o, colaboraÃ§Ã£o e histÃ³rico de alteraÃ§Ãµes.

---

## âš™ï¸ Tecnologias
- Python (pandas, sqlite3, matplotlib, seaborn)
- Google Colab
- Google Drive (armazenamento do banco de dados)
- SQLite (banco local)
- GitHub (versionamento de cÃ³digo)

---

## ğŸ”— Estrutura do Projeto

1. **Google Drive**: Armazena o banco `super_market.db` de forma persistente.
2. **SQLite**: Gerencia os dados diretamente pelo Colab.
3. **GitHub**: Guarda o cÃ³digo-fonte e notebooks.

---

âš™ï¸ **Como executar o notebook no Colab:**

1ï¸âƒ£ **Executar tudo de uma vez:**  
Ideal ao abrir o notebook pela primeira vez.  
VÃ¡ em **Ambiente de execuÃ§Ã£o > Executar tudo** ou use o atalho `Ctrl+F9`.

2ï¸âƒ£ **Executar a partir de uma cÃ©lula:**  
Ãštil se vocÃª jÃ¡ rodou parte do cÃ³digo e quer continuar.  
Clique na cÃ©lula desejada e vÃ¡ em **Ambiente de execuÃ§Ã£o > Executar a partir daqui**.

3ï¸âƒ£ **Executar manualmente (uma por uma):**  
Use `Shift+Enter` em cada cÃ©lula para rodar individualmente.  
Ã“timo para revisar ou testar partes do cÃ³digo.
____________________________________________________________________

# ğŸ‘¨â€ğŸ’» Iniciando: toda vez que abrir o notebook
ğŸŒ 1. Montar o Google Drive: drive.mount('/content/drive')

ğŸ“ 2. Definir o caminho do banco de dados no Drive

ğŸ”Œ 3. Conectar ao banco SQLite: con = sqlite3.connect(caminho_banco)

ğŸ“š 4. Importar as bibliotecas (pandas, sqlite3, os, etc.)

âš ï¸ Verifique se o con.close() estÃ¡ comentado no final para evitar desconexÃ£o durante a execuÃ§Ã£o completa

---

**ğŸŒEtapa 1 - Montar o Google Drive (sempre ao abrir o notebook)** : Conecta seu Google Drive ao Colab para acessar e salvar arquivos diretamente, como o banco de dados SQLite.
"""

from google.colab import drive  # Importa a funÃ§Ã£o para conectar o Google Drive no Colab
drive.mount('/content/drive')   # Monta o Drive no diretÃ³rio /content/drive para acesso aos arquivos

"""ğŸ—‚ï¸ **Etapa 2 â€“ Definir o caminho do banco de dados no Drive (sempre apÃ³s montar o Drive):**  
Especificamos o caminho onde o arquivo `super_market.db` serÃ¡ salvo e garantimos que a pasta exista no Google Drive.

"""

import os  # Biblioteca para manipular caminhos e pastas no sistema operacional
caminho_banco = '/content/drive/MyDrive/Colab Notebooks/super_market/super_market.db'  # Caminho completo do banco no Drive
os.makedirs(os.path.dirname(caminho_banco), exist_ok=True)  # Cria a pasta se ainda nÃ£o existir

"""ğŸ›¢ **Etapa 3 â€“ Conectar ao banco SQLite (sempre apÃ³s definir o caminho):**  Estabelece a conexÃ£o com o banco de dados `super_market.db` no Drive.Se o arquivo nÃ£o existir, serÃ¡ criado automaticamente."""

import sqlite3  # Biblioteca para trabalhar com bancos SQLite em Python
con = sqlite3.connect(caminho_banco) # Conecta ao banco usando o caminho definido
cursor = con.cursor() # Cria um cursor para executar comandos SQL

"""ğŸ“š **Etapa 4 - Importando bibliotecas essenciais:**  
Estas bibliotecas sÃ£o utilizadas ao longo do notebook para anÃ¡lise, visualizaÃ§Ã£o e manipulaÃ§Ã£o de dados.
"""

# Lista de bibiliotecas python
import pandas as pd               # ManipulaÃ§Ã£o de dados com DataFrames
import sqlite3                    # ConexÃ£o e comandos SQL com banco SQLite
import csv                        # Leitura e escrita de arquivos CSV
import os                         # OperaÃ§Ãµes com arquivos e diretÃ³rios
import matplotlib.pyplot as plt   # VisualizaÃ§Ã£o de dados
import seaborn as sns             # VisualizaÃ§Ã£o de dados

"""---
# âœï¸ Realizando alteraÃ§Ãµes no cÃ³digo:
- Criar, consultar, inserir, atualizar e excluir dados
- Usar pandas, seaborn, matplotlib para anÃ¡lises e visualizaÃ§Ãµes
- Sempre que fizer mudanÃ§as no banco, execute: con.commit()

**ğŸš« O que vocÃª nÃ£o precisa executar sempre:**

- Criar tabelas jÃ¡ existentes
- Inserir dados duplicados
- Clonar GitHub se jÃ¡ foi feito nesta sessÃ£o
---

ğ„œ  **Criando a tabela `Products`:**  
Tabela usada para armazenar os produtos disponÃ­veis no sistema.  
Inclui dados como nome do item, categoria, estoque, tipo e preÃ§os de compra/venda.  
A coluna `OrderID` funciona como identificador Ãºnico para cada produto.
"""

cursor.execute("""
    CREATE TABLE IF NOT EXISTS Products (
        OrderID INTEGER PRIMARY KEY AUTOINCREMENT,
        Item TEXT NOT NULL,
        Category TEXT,
        Stock INTEGER DEFAULT 0,
        Type TEXT,
        Purchase_Price REAL NOT NULL,
        Sale_Price REAL CHECK(Sale_Price >= 0)
    )
""")
con.commit()  # ğŸ’¾ Salva a criaÃ§Ã£o da tabela no banco

"""ğŸ” Consultar tabelas existentes no banco:
Usado para verificar quais tabelas jÃ¡ foram criadas no banco de dados SQLite.
"""

result = cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
result.fetchall()

"""ğŸ“‘ **Importar e Ler o CSV com pandas**  
Nesta etapa, usamos o pandas para ler o arquivo CSV com os dados dos produtos que serÃ£o inseridos no banco de dados.
"""

# Lendo o CSV
df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/super_market/products_supermarket.csv')
# Visualiza as primeiras linhas
df.head(5)

"""ğŸ› ï¸ **Renomear colunas para combinar com a tabela SQL**  
Renomeamos as colunas do DataFrame para garantir que os nomes sejam exatamente os mesmos da tabela criada no banco SQLite.
"""

df.rename(columns={
    'Order': 'OrderID',
    'Purchase Price (USD)': 'Purchase_Price',
    'Sale Price (USD)': 'Sale_Price'
}, inplace=True)
con.commit()

"""ğŸ” **Verificar se as colunas estÃ£o corretas**  
Antes de importar os dados, exibimos os nomes das colunas e as primeiras linhas do DataFrame para conferir se estÃ¡ tudo certo.
"""

print("Colunas do DataFrame:", df.columns.tolist())
df.head()

"""ğŸ§© **Inserir dados no banco de dados**  
Percorremos cada linha do DataFrame e inserimos os dados na tabela `Products`, usando `INSERT OR IGNORE INTO
"""

for _, row in df.iterrows():
    cursor.execute("""
        INSERT OR IGNORE INTO Products (OrderID, Item, Category, Stock, Type, Purchase_Price, Sale_Price)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    """, tuple(row))
con.commit()

"""ğŸ§ **Verificar dados salvos da tabela no banco**  
consulta na tabela para exibir os dados jÃ¡ inseridos e garantir que o processo de importaÃ§Ã£o foi bem-sucedido.
"""

df_produtos = pd.read_sql_query("SELECT * FROM Products", con)
df_produtos.head()  # Mostra as 5 primeiras linhas

"""ğŸ’¯ Total de Produtos inseridos: A quantidade de produtos, importados do '.csv' inseridos na tabela 'Products' do banco de dados 'super-market.db'"""

df_verificacao = pd.read_sql_query("SELECT * FROM Products", con)
print(f'Total de registros inseridos: {len(df_verificacao)}')

"""---
# ğŸ“¥ Antes de fechar o notebook:
- ğŸ’¾ Execute con.commit() para salvar tudo
- â›” Execute con.close() para desconectar com seguranÃ§a
- ğŸ—ƒï¸ Confirme que o arquivo foi salvo no Google Drive
---

ğŸ’¾ **Salvar alteraÃ§Ãµes no banco de dados**  
Executamos `con.commit()` para confirmar as alteraÃ§Ãµes e garantir que os dados fiquem salvos de forma permanente.
"""

con.commit()
print("âœ… Dados importados com sucesso para o banco SQLite!")

"""### ğŸ”’ Executar esta cÃ©lula SOMENTE ao finalizar todo o trabalho com o banco. retirar cometarios (#)
ğŸ”Œ **Fechar a conexÃ£o com o banco**  
Fechamos a conexÃ£o com o SQLite apÃ³s terminar as operaÃ§Ãµes, liberando recursos do sistema.
"""

# ğŸ”’ Fechar conexÃ£o com o banco de dados (sÃ³ executar ao finalizar tudo)
# Use esta cÃ©lula apenas quando terminar TODAS as ediÃ§Ãµes e inserÃ§Ãµes no banco
# con.close()
# print("âœ… Banco de dados desconectado com sucesso.")

"""---
# âš™ï¸ 5. Coisas opcionais:
- Fazer backup no GitHub
- Baixar o .db localmente
- Comentar o con.close() se quiser continuar testando
- Deixar este checklist visÃ­vel e organizado no topo do notebook
---

ğŸ‘¨â€ğŸ’» **Salvar no GitHub**  
ApÃ³s as alteraÃ§Ãµes, podemos fazer backup do notebook e/ou do banco de dados, enviando-os para um repositÃ³rio no GitHub como forma de controle de versÃ£o.
"""

# Commented out IPython magic to ensure Python compatibility.
# @title
'''# â˜ï¸ Etapa: Backup automÃ¡tico no GitHub (com token oculto)

from getpass import getpass  # Para ocultar a digitaÃ§Ã£o do token
import shutil

# ğŸ” Digitar token manualmente (nÃ£o aparece na tela)
token = getpass("Digite seu GitHub Personal Access Token (oculto): ")

# Seus dados do repositÃ³rio
usuario = "italomellors"
repositorio = "Data_Analysis_Projects"

# ğŸ§² Clonar o repositÃ³rio (sÃ³ uma vez por sessÃ£o)
!git clone https://{token}:x-oauth-basic@github.com/{usuario}/{repositorio}.git

# ğŸ“‚ Mudar para a pasta do repositÃ³rio clonado
# %cd {repositorio}

# ğŸ“ Copiar o banco do Drive para o repositÃ³rio local
shutil.copy('/content/drive/MyDrive/Colab Notebooks/super_market/super_market.db', './super_market.db')

# âœ… Git: Preparar, registrar e enviar os arquivos
!git status
!git add super_market.db
!git commit -m "Backup automÃ¡tico do banco de dados SQLite"
!git push'''